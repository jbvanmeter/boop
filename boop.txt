What I loved most about making this game was how often I was required to use all of the tools I had at my disposal - however limited - and think outside of the box to achieve the exact appearances and game functions I wanted.

The start screen logo animation was achieved using an initial "setInterval" timer on screen load to increase the width of the logo image and a nested "if/else" statement to call a clearInterval on the timer once it had reached a certain width. Another "setInterval" timer with a nested "if/else" statement was subsequently specified using a "setTimeout" command to shrink the logo to its final size. I used setInterval (and setTimeouts) extensively throughout the game to achieve animation effects by appending/removing child element nodes and manipulating element node heights, widths, opacities, etc.

"While" loops were useful for removing all visible elements before progressing with gameplay and appending more elements to the main body element. However - when starting a new game after the end of a previous game, I encountered issues with previous iterations/properties of removed child elements re-appearing when new instantiations of those elements were generated (including eventListeners, which I had attempted to account for when creating functions to terminate a game or start a new game). My workaround for this was by writing a function that just completely reloaded the page each time the player made a selection to start a new game.

Creating the game grid was accomplished by defining a class of object to define what the circles should look like and an empty array to make it possibile to assign an array index value to each circle. I then wrote a function to create a single circle element node, then cloned that node 34 times (pushing each one to the "gameGrid" array). Math.floor + Math.random was used pick a number => 1 and <=35 (but defined specifically as "gameGrid.length").

I wrote and debugged all of the JS for "easy" difficulty setting first, and then essentially copied and pasted for the "medium" and "hard" function calls (making the minimal adjustments I needed to make for the probability functions associated with smiley face vs. bomb instantiation, setInterval timers for the speed at which faces/bombs would appear, etc). This probably could be minimized specifying those data points as parameters of a general "playGame" function - but there was a lot of trial and error initially, so understanding how to framework that function would be useful to tidy up the code in subsequent versions of the game.

One of the more frustrating challenges I faced was getting only one object to appear in the grid at any given time. I had initially used two separate elements to identify 1) a smiley face, and 2) a bomb. I eventually realized that I needed to see them as the same element - but just a different type of instantiation that determined the source image and eventListeners (linked to the outcome of the probability function). Otherwise... faces would only replace faces, and bombs would only replace bombs... leaving bombs to idle in the grid while faces continued populating elsewhere (and vice versa).

Another challenge I faced was cancelling the setTimeout command to end the game after 30 seconds/display a score if the user had instead "booped" a bomb and had the game end early. I eventually achieved this by adding a variable called "exitEarly" that I treated like the variable "plusOne" (used to aggregate the user's score) - and the eventListener that triggered the bomb explosion would add a "+1" to its value. I then rewrote the function to toggle the traditional end-of-game sequence to return a null value (and thus not execute any further) if the value of "exitEarly" did not equal 0. Otherwise, after 30 seconds, the setTimeout to display a score would execute even if the user had lost the game by "bombing" out.